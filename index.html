<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Kitava Delivery Density</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif}
    #map{height:100vh}

    .legend{
      position:absolute;right:12px;top:12px;z-index:1200;
      background:white;padding:10px;border-radius:6px;
      box-shadow:0 1px 4px rgba(0,0,0,0.15);
      font-size:13px
    }
    .legend .row{display:flex;align-items:center;margin-top:6px}
    .legend .swatch{
      width:24px;height:14px;margin-right:8px;
      border:1px solid #ddd
    }
    .legend .note{margin-top:8px;color:#666;font-size:12px}
  </style>
</head>
<body>

<div id="map"></div>

<div id="legend" class="legend">
  <strong>Orders per area</strong>

  <div style="margin-top:8px"><strong>Albany</strong></div>
  <div id="albLegend"></div>

  <div style="margin-top:8px"><strong>Temescal</strong></div>
  <div id="temLegend"></div>

  <div class="note">
    Very light = 1–4 orders<br>
    Darker = higher volume
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>

<script>
// =====================
// EMBEDDED CSV (unchanged)
// =====================
const CSV_TEXT = `Cx Lat,Cx Long,Store Name,# of Deliveries
${/* keep your full CSV exactly as-is here */''}`;

// =====================
// CONFIG
// =====================
const CELL_KM = 0.35;
const FAINT_THRESHOLD = 4; // 1–4 orders = very light
const COLOR_THRESHOLD = 5; // 5+ orders = normal color

// =====================
// MAP
// =====================
const map = L.map('map').setView([37.87,-122.27],12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
  attribution:'© OpenStreetMap'
}).addTo(map);

// =====================
// PARSE CSV
// =====================
const parsed = Papa.parse(CSV_TEXT, {header:true, skipEmptyLines:true});
const pts = [];

parsed.data.forEach(r=>{
  const lat = parseFloat(r['Cx Lat']);
  const lon = parseFloat(r['Cx Long']);
  const store = r['Store Name'] || '';
  const count = parseInt(r['# of Deliveries']) || 0;
  if (isFinite(lat) && isFinite(lon)){
    pts.push(turf.point([lon,lat],{store,count}));
  }
});

const ptsFC = turf.featureCollection(pts);
const bbox = turf.bbox(ptsFC);
const padKm = CELL_KM * 1.5;
const avgLat = (bbox[1]+bbox[3])/2;

const padded = [
  bbox[0]-padKm/(111*Math.cos(avgLat*Math.PI/180)),
  bbox[1]-padKm/111,
  bbox[2]+padKm/(111*Math.cos(avgLat*Math.PI/180)),
  bbox[3]+padKm/111
];

const grid = turf.hexGrid(padded, CELL_KM, {units:'kilometers'});

// =====================
// AGGREGATE
// =====================
const totals = [];

grid.features.forEach(hex=>{
  let albany=0, temescal=0;
  const inside = turf.pointsWithinPolygon(ptsFC, hex);
  inside.features.forEach(p=>{
    const c = p.properties.count;
    if (p.properties.store.includes('Albany')) albany+=c;
    else if (p.properties.store.includes('Temescal')) temescal+=c;
  });
  hex.properties = {albany, temescal, total: albany+temescal};
  totals.push(hex.properties.total);
});

const maxTotal = Math.max(...totals, COLOR_THRESHOLD);

// Color scales start at 5 orders
const albScale = chroma.scale(['#e6f0fa','#1f78b4']).domain([COLOR_THRESHOLD,maxTotal]);
const temScale = chroma.scale(['#e6f5e9','#33a02c']).domain([COLOR_THRESHOLD,maxTotal]);

// =====================
// STYLE HEXES
// =====================
grid.features.forEach(hex=>{
  const {albany, temescal, total} = hex.properties;

  if (total >= COLOR_THRESHOLD){
    hex.properties.winner = albany >= temescal ? 'Albany' : 'Temescal';
    hex.properties.fill =
      hex.properties.winner === 'Albany'
        ? albScale(total).hex()
        : temScale(total).hex();
    hex.properties.opacity = 0.65;
  } else if (total >= 1){
    hex.properties.winner = albany >= temescal ? 'Albany' : 'Temescal';
    hex.properties.fill =
      hex.properties.winner === 'Albany'
        ? '#e6f0fa'
        : '#e6f5e9';
    hex.properties.opacity = 0.25;
  } else {
    hex.properties.winner = 'None';
  }
});

// =====================
// RENDER
// =====================
const layer = L.geoJSON(grid,{
  style:f=>{
    if (f.properties.winner === 'None'){
      return {color:'#ddd',weight:0.5,fillOpacity:0};
    }
    return {
      color:'#555',
      weight:0.6,
      fillColor:f.properties.fill,
      fillOpacity:f.properties.opacity
    };
  },
  onEachFeature:(f,l)=>{
    l.bindTooltip(
      `<strong>${f.properties.winner}</strong><br>
       Albany: ${f.properties.albany}<br>
       Temescal: ${f.properties.temescal}<br>
       Total: ${f.properties.total}`,
      {sticky:true}
    );
  }
}).addTo(map);

map.fitBounds(layer.getBounds(),{padding:[20,20]});

// =====================
// LEGEND
// =====================
function buildLegend(scale, el){
  el.innerHTML='';
  const steps = 4;
  for (let i=0;i<steps;i++){
    const v = Math.round(COLOR_THRESHOLD + (i/(steps-1))*(maxTotal-COLOR_THRESHOLD));
    const row=document.createElement('div');
    row.className='row';
    const sw=document.createElement('div');
    sw.className='swatch';
    sw.style.background = scale(v).hex();
    row.appendChild(sw);
    row.appendChild(document.createTextNode(v+'+ orders'));
    el.appendChild(row);
  }
}

buildLegend(albScale, document.getElementById('albLegend'));
buildLegend(temScale, document.getElementById('temLegend'));
</script>

</body>
</html>
