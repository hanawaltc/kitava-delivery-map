<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Delivery Honeycomb (scrappy interactive)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-xwE/ABf4v7qk5g0n2rY6r7FH3z6Qw5v0sK8s9TQm0TY=" crossorigin=""/>
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    .legend { background: white; padding: 8px; line-height: 1.2; font-family: Arial, sans-serif; font-size: 13px; border-radius: 4px; box-shadow: 0 1px 4px rgba(0,0,0,0.2);}
    .info { position: absolute; top: 12px; right: 12px; z-index: 1000; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="info">
    <div id="legend" class="legend"></div>
  </div>

  <!-- Libraries: PapaParse for CSV, Turf for geoprocessing, chroma for colors, Leaflet for map -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-o9N1j+8+QKFd1sKk3c+QG6hKef1yn1xyXQ+v9Zq6u4M=" crossorigin=""></script>

  <script>
  // CONFIG: adjust these as you like
  const CSV_FILENAME = 'deliveries.csv'; // put your CSV here
  const HEX_CELL_SIDE_KM = 0.5; // 0.5 km (500 m). Increase for coarser, decrease for finer
  const COLOR_SCALE = ['#fff7fb','#08306b']; // low -> high
  const MIN_VISIBLE_COUNT = 1; // min aggregated deliveries to show a colored hex

  // Initialize map
  const map = L.map('map').setView([37.67, -122.12], 13);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const hexLayerGroup = L.geoJSON(null, {
    style: feature => {
      const c = feature.properties.count || 0;
      const opacity = c > 0 ? 0.8 : 0.15;
      const fill = c >= MIN_VISIBLE_COUNT ? chroma.scale(COLOR_SCALE).domain([0, maxCount || 1])(c).hex() : '#ffffff';
      return {
        color: '#888',
        weight: c >= MIN_VISIBLE_COUNT ? 0.6 : 0.25,
        fillColor: fill,
        fillOpacity: opacity
      };
    },
    onEachFeature: (feature, layer) => {
      const c = feature.properties.count || 0;
      const tooltip = `<strong>Deliveries:</strong> ${c}<br><small>Hex id: ${feature.properties.hex_id || 'n/a'}</small>`;
      layer.bindTooltip(tooltip, {sticky: true});
    }
  }).addTo(map);

  let maxCount = 0;

  function showLegend(maxVal) {
    const legendDiv = document.getElementById('legend');
    if (!maxVal || maxVal === 0) {
      legendDiv.innerHTML = '<strong>Deliveries</strong><br><small>No deliveries in view.</small>';
      return;
    }
    // Create 5 buckets
    const steps = 5;
    const values = [];
    for (let i=0;i<=steps;i++){
      values.push(Math.round(i*(maxVal/steps)));
    }
    const scale = chroma.scale(COLOR_SCALE).domain([0, maxVal]);
    let html = '<strong>Deliveries</strong><br>';
    for (let i=0;i<steps;i++){
      const v = values[i+1];
      const color = scale((values[i]+values[i+1])/2).hex();
      html += `<div style="display:flex;align-items:center;"><div style="width:18px;height:14px;background:${color};margin-right:8px;border:1px solid #ddd"></div><div>${values[i+0]} &ndash; ${v}</div></div>`;
    }
    legendDiv.innerHTML = html;
  }

  // Load CSV, convert to turf points
  fetch(CSV_FILENAME).then(r => {
    if (!r.ok) throw new Error('Could not fetch ' + CSV_FILENAME + '. Serve via HTTP or check filename.');
    return r.text();
  }).then(txt => {
    const parsed = Papa.parse(txt, {header: true, skipEmptyLines: true});
    const rows = parsed.data;
    // convert to turf points, also collect bounds
    const features = [];
    for (const r of rows) {
      const lat = parseFloat(r['Cx Lat']);
      const lon = parseFloat(r['Cx Long']);
      const deliveries = parseInt(r['# of Deliveries']) || 0;
      if (isFinite(lat) && isFinite(lon)) {
        features.push(turf.point([lon, lat], {deliveries: deliveries, store: r['Store Name'] || ''}));
      }
    }
    if (features.length === 0) {
      alert('No valid points found in CSV. Ensure headers include Cx Lat,Cx Long,# of Deliveries');
      return;
    }
    const pointsFC = turf.featureCollection(features);

    // compute bbox and slightly pad
    const bbox = turf.bbox(pointsFC);
    // pad bbox by 1 cell side
    const padKM = HEX_CELL_SIDE_KM * 1.5;
    // turf.buffer works with polygons; simpler: expand bbox coordinates by degrees using approximate conversion:
    // We'll compute pad in degrees approximately: 1 degree lat ~111 km. For lon use cos(avg lat).
    const minLat = bbox[1], maxLat = bbox[3];
    const avgLat = (minLat + maxLat) / 2;
    const degPadLat = padKM / 111.0;
    const degPadLon = padKM / (111.0 * Math.cos(avgLat * Math.PI/180));
    const padded = [bbox[0] - degPadLon, bbox[1] - degPadLat, bbox[2] + degPadLon, bbox[3] + degPadLat];

    // create hex grid
    const hexGrid = turf.hexGrid(padded, HEX_CELL_SIDE_KM, {units: 'kilometers'});

    // For each hex, sum deliveries of contained points
    const hexFeatures = hexGrid.features.map((hexFeat, i) => {
      // turf.pointsWithinPolygon returns features inside
      const pts = turf.pointsWithinPolygon(pointsFC, hexFeat);
      let total = 0;
      for (const p of pts.features) total += (p.properties.deliveries || 0);
      hexFeat.properties.count = total;
      // add an id
      hexFeat.properties.hex_id = 'hex-' + i;
      return hexFeat;
    });

    // compute max for color scaling
    maxCount = Math.max(...hexFeatures.map(h => h.properties.count || 0));
    // filter out empty if you want; but keep them faint for context
    const hexFC = turf.featureCollection(hexFeatures);

    // add to map
    hexLayerGroup.addData(hexFC);

    // fit to bounds
    const allBounds = turf.bbox(hexFC);
    map.fitBounds([[allBounds[1], allBounds[0]], [allBounds[3], allBounds[2]]], {padding: [20,20]});

    showLegend(maxCount);
  }).catch(err => {
    console.error(err);
    alert('Error loading CSV: ' + err.message + '. If opening locally, serve via HTTP (GitHub Pages or simple local server).');
  });

  </script>
</body>
</html>
